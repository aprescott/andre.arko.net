---
title: "How to Safely Store User Data"
layout: post
---

So, you have a web application, and you want to store some data "securely". Right now, you're you probably thinking "I know this already, we should encrypt it!". No.

Encryption is a last ditch option, and the least secure of the legitimate options for handling sensitive data. Only do encryption if you absolutely have to and there is no other option. Let's look at all the options for secure storage, and which one you should use. We'll start with the better options.

First option: don't. Don't store it, don't look at it, don't let employees see it, don't let yourself see it. The only way for the data to be absolutely secure is if you absolutely don't have it. There's a pretty good FAQ about the problems with storing data at [plaintextoffenders.com](http://plaintextoffenders.com/faq/devs), but the short version is: do everything you can to not store things. It is not possible to lose data that you don't have.

Even if you think you need to store it, you probably don't. When I worked at [Wesabe](http://en.wikipedia.org/wiki/Wesabe), we stored financial transactions. But we didn't save the foreign key for transactions in user accounts. [Even employees couldn't connect purchases to a name or email address](http://web.archive.org/web/20100731183631/http://blog.wesabe.com/2007/02/23/safeguarding-your-data-the-privacy-wall/). Only the user's password could do that. 

So first, try to not store the data. Instead, store something that can be reconstructed when the user logs in with their password, stored only in memory, and expired every few minutes or as soon as the user logs out, whichever comes first. 

Next option: [use bcrypt](http://codahale.com/how-to-safely-store-a-password/). If you must be able to verify some secure data, like a password, don't store it. Never store your site passwords in plaintext. Never store your site passwords encrypted. Use bcrypt to hash the password, and store the hash. In fact, don't just has the password. That allows hackers who steal your database to easily try every possible password until they find the one you hashed. If you're writing a Rails app, use [bcrypt-ruby](https://github.com/codahale/bcrypt-ruby) or [devise](https://github.com/plataformatec/devise). If you're not using Rails, use the bcrypt library for your language. Whenever you use bcrypt, increase the bcrypt difficulty (sometimes called the work factor) as high as you can while still logging in a correct password within a few hundred milliseconds.

Third option: actually encrypt the data. Again, avoid this if you possibly can. It provides a juicer target for hacking, and makes it possible for a breach to disclose _all_ of the data you have stored without any additional per-user work by if you are hacked. If there just isn't any way to avoid encrypting some of the data, make sure that you're doing it as safely as you can. Always generate your key using a tool that is known to produce good randomness (in Ruby, use the `ActiveSupport::SecureRandom` class). Generate a different key for every environment. Never share any your keys between development, test, staging, qa, and production environments.

Also, very importantly, split your key up. Store part of it in the database as part of the user profile, different for every user in your system. This means brute forcing a single key will not allow you to decrypt every other user's data. Store part of the key in your codebase (but use a different value in each environment). This means that a copy of the database (without a copy of the application source code) will not allow all the data to be decrypted. Finally, store another part of the key in an environment variable that is only available to the application servers while they are running. Generate that part of the key separately for each environment (test, staging, qa, production), and don't store it anywhere your database or source code is stored.

Splitting the key up this way means that even attacks that reveal the source code of your running application (which are sadly somewhat common), combined with a complete copy of the database (likewise sadly common) still does not reveal the entire key. Every one of these partitions is important: database breaches, code breaches, and code execution breaches often require different security holes. If all three are required to get the entire encryption key, it is significantly less likely that a single breach will result in all of your users' "secure" data being leaked.

You really don't want your users' data to be leaked. California and many other states require notification of data breaches to every user in a timely manner or companies face stiff fines. If your company is sued over the breach and found liable, the resulting judgement could be huge.

One last note: treat all of your own internal credentials in the same way described here! Careless handling of your own usernames, passwords, and keys can allow a relatively minor hack to escalate into something that destroys your company. Just ask Code Spaces, whose entire company was [destroyed by a leak of a minor key](http://arstechnica.com/security/2014/06/aws-console-breach-leads-to-demise-of-service-with-proven-backup-plan/). They just used the key to upload files to AWS S3, but that key was also able to delete every server, file, database, and database backup that the company had. A single hack of a "minor" key destroyed the entire company. Don't let that happen to you!

This stuff is company making or breaking, so think about what you're doing and why you're doing it. Ask for advice from people who know their stuff. Fix small security issues before they combine with other small security issues to become a huge security issue. And definitely follow (at a minimum!) the steps outlined above.
